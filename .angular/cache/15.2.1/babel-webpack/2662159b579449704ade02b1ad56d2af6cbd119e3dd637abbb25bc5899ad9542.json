{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Inject, NgModule, Optional, SkipSelf } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\nimport { mergeMap } from 'rxjs/operators';\nimport { from } from 'rxjs';\nimport { HTTP_INTERCEPTORS } from '@angular/common/http';\nconst JWT_OPTIONS = new InjectionToken('JWT_OPTIONS');\n\n// tslint:disable:no-bitwise\nclass JwtHelperService {\n  constructor(config = null) {\n    this.tokenGetter = config && config.tokenGetter || function () {};\n  }\n  urlBase64Decode(str) {\n    let output = str.replace(/-/g, '+').replace(/_/g, '/');\n    switch (output.length % 4) {\n      case 0:\n        {\n          break;\n        }\n      case 2:\n        {\n          output += '==';\n          break;\n        }\n      case 3:\n        {\n          output += '=';\n          break;\n        }\n      default:\n        {\n          throw new Error('Illegal base64url string!');\n        }\n    }\n    return this.b64DecodeUnicode(output);\n  }\n  // credits for decoder goes to https://github.com/atk\n  b64decode(str) {\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n    let output = '';\n    str = String(str).replace(/=+$/, '');\n    if (str.length % 4 === 1) {\n      throw new Error(`'atob' failed: The string to be decoded is not correctly encoded.`);\n    }\n    for (\n    // initialize result and counters\n    let bc = 0, bs, buffer, idx = 0;\n    // get next character\n    buffer = str.charAt(idx++);\n    // character found in table? initialize bit storage and add its ascii value;\n    ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,\n    // and if not first of each 4 characters,\n    // convert the first 8 bits to one ascii character\n    bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {\n      // try to find character in table (0-63, not found => -1)\n      buffer = chars.indexOf(buffer);\n    }\n    return output;\n  }\n  b64DecodeUnicode(str) {\n    return decodeURIComponent(Array.prototype.map.call(this.b64decode(str), c => {\n      return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n    }).join(''));\n  }\n  decodeToken(token = this.tokenGetter()) {\n    if (!token || token === '') {\n      return null;\n    }\n    const parts = token.split('.');\n    if (parts.length !== 3) {\n      throw new Error(`The inspected token doesn't appear to be a JWT. Check to make sure it has three parts and see https://jwt.io for more.`);\n    }\n    const decoded = this.urlBase64Decode(parts[1]);\n    if (!decoded) {\n      throw new Error('Cannot decode the token.');\n    }\n    return JSON.parse(decoded);\n  }\n  getTokenExpirationDate(token = this.tokenGetter()) {\n    let decoded;\n    decoded = this.decodeToken(token);\n    if (!decoded || !decoded.hasOwnProperty('exp')) {\n      return null;\n    }\n    const date = new Date(0);\n    date.setUTCSeconds(decoded.exp);\n    return date;\n  }\n  isTokenExpired(token = this.tokenGetter(), offsetSeconds) {\n    if (!token || token === '') {\n      return true;\n    }\n    const date = this.getTokenExpirationDate(token);\n    offsetSeconds = offsetSeconds || 0;\n    if (date === null) {\n      return false;\n    }\n    return !(date.valueOf() > new Date().valueOf() + offsetSeconds * 1000);\n  }\n  getAuthScheme(authScheme, request) {\n    if (typeof authScheme === 'function') {\n      return authScheme(request);\n    }\n    return authScheme;\n  }\n}\nJwtHelperService.ɵfac = function JwtHelperService_Factory(t) {\n  return new (t || JwtHelperService)(i0.ɵɵinject(JWT_OPTIONS));\n};\nJwtHelperService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: JwtHelperService,\n  factory: JwtHelperService.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(JwtHelperService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [JWT_OPTIONS]\n      }]\n    }];\n  }, null);\n})();\nclass JwtInterceptor {\n  constructor(config, jwtHelper, document) {\n    this.jwtHelper = jwtHelper;\n    this.document = document;\n    this.standardPorts = ['80', '443'];\n    this.tokenGetter = config.tokenGetter;\n    this.headerName = config.headerName || 'Authorization';\n    this.authScheme = config.authScheme || config.authScheme === '' ? config.authScheme : 'Bearer ';\n    this.allowedDomains = config.allowedDomains || [];\n    this.disallowedRoutes = config.disallowedRoutes || [];\n    this.throwNoTokenError = config.throwNoTokenError || false;\n    this.skipWhenExpired = config.skipWhenExpired;\n  }\n  isAllowedDomain(request) {\n    const requestUrl = new URL(request.url, this.document.location.origin);\n    // If the host equals the current window origin,\n    // the domain is allowed by default\n    if (requestUrl.host === this.document.location.host) {\n      return true;\n    }\n    // If not the current domain, check the allowed list\n    const hostName = `${requestUrl.hostname}${requestUrl.port && !this.standardPorts.includes(requestUrl.port) ? ':' + requestUrl.port : ''}`;\n    return this.allowedDomains.findIndex(domain => typeof domain === 'string' ? domain === hostName : domain instanceof RegExp ? domain.test(hostName) : false) > -1;\n  }\n  isDisallowedRoute(request) {\n    const requestedUrl = new URL(request.url, this.document.location.origin);\n    return this.disallowedRoutes.findIndex(route => {\n      if (typeof route === 'string') {\n        const parsedRoute = new URL(route, this.document.location.origin);\n        return parsedRoute.hostname === requestedUrl.hostname && parsedRoute.pathname === requestedUrl.pathname;\n      }\n      if (route instanceof RegExp) {\n        return route.test(request.url);\n      }\n      return false;\n    }) > -1;\n  }\n  handleInterception(token, request, next) {\n    const authScheme = this.jwtHelper.getAuthScheme(this.authScheme, request);\n    let tokenIsExpired = false;\n    if (!token && this.throwNoTokenError) {\n      throw new Error('Could not get token from tokenGetter function.');\n    }\n    if (this.skipWhenExpired) {\n      tokenIsExpired = token ? this.jwtHelper.isTokenExpired(token) : true;\n    }\n    if (token && tokenIsExpired && this.skipWhenExpired) {\n      request = request.clone();\n    } else if (token) {\n      request = request.clone({\n        setHeaders: {\n          [this.headerName]: `${authScheme}${token}`\n        }\n      });\n    }\n    return next.handle(request);\n  }\n  intercept(request, next) {\n    if (!this.isAllowedDomain(request) || this.isDisallowedRoute(request)) {\n      return next.handle(request);\n    }\n    const token = this.tokenGetter(request);\n    if (token instanceof Promise) {\n      return from(token).pipe(mergeMap(asyncToken => {\n        return this.handleInterception(asyncToken, request, next);\n      }));\n    } else {\n      return this.handleInterception(token, request, next);\n    }\n  }\n}\nJwtInterceptor.ɵfac = function JwtInterceptor_Factory(t) {\n  return new (t || JwtInterceptor)(i0.ɵɵinject(JWT_OPTIONS), i0.ɵɵinject(JwtHelperService), i0.ɵɵinject(DOCUMENT));\n};\nJwtInterceptor.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: JwtInterceptor,\n  factory: JwtInterceptor.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(JwtInterceptor, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [JWT_OPTIONS]\n      }]\n    }, {\n      type: JwtHelperService\n    }, {\n      type: Document,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, null);\n})();\nclass JwtModule {\n  constructor(parentModule) {\n    if (parentModule) {\n      throw new Error(`JwtModule is already loaded. It should only be imported in your application's main module.`);\n    }\n  }\n  static forRoot(options) {\n    return {\n      ngModule: JwtModule,\n      providers: [{\n        provide: HTTP_INTERCEPTORS,\n        useClass: JwtInterceptor,\n        multi: true\n      }, options.jwtOptionsProvider || {\n        provide: JWT_OPTIONS,\n        useValue: options.config\n      }, JwtHelperService]\n    };\n  }\n}\nJwtModule.ɵfac = function JwtModule_Factory(t) {\n  return new (t || JwtModule)(i0.ɵɵinject(JwtModule, 12));\n};\nJwtModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: JwtModule\n});\nJwtModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(JwtModule, [{\n    type: NgModule\n  }], function () {\n    return [{\n      type: JwtModule,\n      decorators: [{\n        type: Optional\n      }, {\n        type: SkipSelf\n      }]\n    }];\n  }, null);\n})();\n\n/*\n * Public API Surface of angular-jwt\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { JWT_OPTIONS, JwtHelperService, JwtInterceptor, JwtModule };","map":{"version":3,"names":["i0","InjectionToken","Injectable","Inject","NgModule","Optional","SkipSelf","DOCUMENT","mergeMap","from","HTTP_INTERCEPTORS","JWT_OPTIONS","JwtHelperService","constructor","config","tokenGetter","urlBase64Decode","str","output","replace","length","Error","b64DecodeUnicode","b64decode","chars","String","bc","bs","buffer","idx","charAt","fromCharCode","indexOf","decodeURIComponent","Array","prototype","map","call","c","charCodeAt","toString","slice","join","decodeToken","token","parts","split","decoded","JSON","parse","getTokenExpirationDate","hasOwnProperty","date","Date","setUTCSeconds","exp","isTokenExpired","offsetSeconds","valueOf","getAuthScheme","authScheme","request","ɵfac","ɵprov","type","undefined","decorators","args","JwtInterceptor","jwtHelper","document","standardPorts","headerName","allowedDomains","disallowedRoutes","throwNoTokenError","skipWhenExpired","isAllowedDomain","requestUrl","URL","url","location","origin","host","hostName","hostname","port","includes","findIndex","domain","RegExp","test","isDisallowedRoute","requestedUrl","route","parsedRoute","pathname","handleInterception","next","tokenIsExpired","clone","setHeaders","handle","intercept","Promise","pipe","asyncToken","Document","JwtModule","parentModule","forRoot","options","ngModule","providers","provide","useClass","multi","jwtOptionsProvider","useValue","ɵmod","ɵinj"],"sources":["D:/New folder/AngularAuthUI/node_modules/@auth0/angular-jwt/fesm2015/auth0-angular-jwt.js"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Inject, NgModule, Optional, SkipSelf } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\nimport { mergeMap } from 'rxjs/operators';\nimport { from } from 'rxjs';\nimport { HTTP_INTERCEPTORS } from '@angular/common/http';\n\nconst JWT_OPTIONS = new InjectionToken('JWT_OPTIONS');\n\n// tslint:disable:no-bitwise\nclass JwtHelperService {\n    constructor(config = null) {\n        this.tokenGetter = (config && config.tokenGetter) || function () { };\n    }\n    urlBase64Decode(str) {\n        let output = str.replace(/-/g, '+').replace(/_/g, '/');\n        switch (output.length % 4) {\n            case 0: {\n                break;\n            }\n            case 2: {\n                output += '==';\n                break;\n            }\n            case 3: {\n                output += '=';\n                break;\n            }\n            default: {\n                throw new Error('Illegal base64url string!');\n            }\n        }\n        return this.b64DecodeUnicode(output);\n    }\n    // credits for decoder goes to https://github.com/atk\n    b64decode(str) {\n        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n        let output = '';\n        str = String(str).replace(/=+$/, '');\n        if (str.length % 4 === 1) {\n            throw new Error(`'atob' failed: The string to be decoded is not correctly encoded.`);\n        }\n        for (\n        // initialize result and counters\n        let bc = 0, bs, buffer, idx = 0; \n        // get next character\n        (buffer = str.charAt(idx++)); \n        // character found in table? initialize bit storage and add its ascii value;\n        ~buffer &&\n            ((bs = bc % 4 ? bs * 64 + buffer : buffer),\n                // and if not first of each 4 characters,\n                // convert the first 8 bits to one ascii character\n                bc++ % 4)\n            ? (output += String.fromCharCode(255 & (bs >> ((-2 * bc) & 6))))\n            : 0) {\n            // try to find character in table (0-63, not found => -1)\n            buffer = chars.indexOf(buffer);\n        }\n        return output;\n    }\n    b64DecodeUnicode(str) {\n        return decodeURIComponent(Array.prototype.map\n            .call(this.b64decode(str), (c) => {\n            return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n        })\n            .join(''));\n    }\n    decodeToken(token = this.tokenGetter()) {\n        if (!token || token === '') {\n            return null;\n        }\n        const parts = token.split('.');\n        if (parts.length !== 3) {\n            throw new Error(`The inspected token doesn't appear to be a JWT. Check to make sure it has three parts and see https://jwt.io for more.`);\n        }\n        const decoded = this.urlBase64Decode(parts[1]);\n        if (!decoded) {\n            throw new Error('Cannot decode the token.');\n        }\n        return JSON.parse(decoded);\n    }\n    getTokenExpirationDate(token = this.tokenGetter()) {\n        let decoded;\n        decoded = this.decodeToken(token);\n        if (!decoded || !decoded.hasOwnProperty('exp')) {\n            return null;\n        }\n        const date = new Date(0);\n        date.setUTCSeconds(decoded.exp);\n        return date;\n    }\n    isTokenExpired(token = this.tokenGetter(), offsetSeconds) {\n        if (!token || token === '') {\n            return true;\n        }\n        const date = this.getTokenExpirationDate(token);\n        offsetSeconds = offsetSeconds || 0;\n        if (date === null) {\n            return false;\n        }\n        return !(date.valueOf() > new Date().valueOf() + offsetSeconds * 1000);\n    }\n    getAuthScheme(authScheme, request) {\n        if (typeof authScheme === 'function') {\n            return authScheme(request);\n        }\n        return authScheme;\n    }\n}\nJwtHelperService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.16\", ngImport: i0, type: JwtHelperService, deps: [{ token: JWT_OPTIONS }], target: i0.ɵɵFactoryTarget.Injectable });\nJwtHelperService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.16\", ngImport: i0, type: JwtHelperService });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.16\", ngImport: i0, type: JwtHelperService, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [JWT_OPTIONS]\n                }] }]; } });\n\nclass JwtInterceptor {\n    constructor(config, jwtHelper, document) {\n        this.jwtHelper = jwtHelper;\n        this.document = document;\n        this.standardPorts = ['80', '443'];\n        this.tokenGetter = config.tokenGetter;\n        this.headerName = config.headerName || 'Authorization';\n        this.authScheme =\n            config.authScheme || config.authScheme === ''\n                ? config.authScheme\n                : 'Bearer ';\n        this.allowedDomains = config.allowedDomains || [];\n        this.disallowedRoutes = config.disallowedRoutes || [];\n        this.throwNoTokenError = config.throwNoTokenError || false;\n        this.skipWhenExpired = config.skipWhenExpired;\n    }\n    isAllowedDomain(request) {\n        const requestUrl = new URL(request.url, this.document.location.origin);\n        // If the host equals the current window origin,\n        // the domain is allowed by default\n        if (requestUrl.host === this.document.location.host) {\n            return true;\n        }\n        // If not the current domain, check the allowed list\n        const hostName = `${requestUrl.hostname}${requestUrl.port && !this.standardPorts.includes(requestUrl.port)\n            ? ':' + requestUrl.port\n            : ''}`;\n        return (this.allowedDomains.findIndex((domain) => typeof domain === 'string'\n            ? domain === hostName\n            : domain instanceof RegExp\n                ? domain.test(hostName)\n                : false) > -1);\n    }\n    isDisallowedRoute(request) {\n        const requestedUrl = new URL(request.url, this.document.location.origin);\n        return (this.disallowedRoutes.findIndex((route) => {\n            if (typeof route === 'string') {\n                const parsedRoute = new URL(route, this.document.location.origin);\n                return (parsedRoute.hostname === requestedUrl.hostname &&\n                    parsedRoute.pathname === requestedUrl.pathname);\n            }\n            if (route instanceof RegExp) {\n                return route.test(request.url);\n            }\n            return false;\n        }) > -1);\n    }\n    handleInterception(token, request, next) {\n        const authScheme = this.jwtHelper.getAuthScheme(this.authScheme, request);\n        let tokenIsExpired = false;\n        if (!token && this.throwNoTokenError) {\n            throw new Error('Could not get token from tokenGetter function.');\n        }\n        if (this.skipWhenExpired) {\n            tokenIsExpired = token ? this.jwtHelper.isTokenExpired(token) : true;\n        }\n        if (token && tokenIsExpired && this.skipWhenExpired) {\n            request = request.clone();\n        }\n        else if (token) {\n            request = request.clone({\n                setHeaders: {\n                    [this.headerName]: `${authScheme}${token}`,\n                },\n            });\n        }\n        return next.handle(request);\n    }\n    intercept(request, next) {\n        if (!this.isAllowedDomain(request) || this.isDisallowedRoute(request)) {\n            return next.handle(request);\n        }\n        const token = this.tokenGetter(request);\n        if (token instanceof Promise) {\n            return from(token).pipe(mergeMap((asyncToken) => {\n                return this.handleInterception(asyncToken, request, next);\n            }));\n        }\n        else {\n            return this.handleInterception(token, request, next);\n        }\n    }\n}\nJwtInterceptor.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.16\", ngImport: i0, type: JwtInterceptor, deps: [{ token: JWT_OPTIONS }, { token: JwtHelperService }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });\nJwtInterceptor.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.16\", ngImport: i0, type: JwtInterceptor });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.16\", ngImport: i0, type: JwtInterceptor, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [JWT_OPTIONS]\n                }] }, { type: JwtHelperService }, { type: Document, decorators: [{\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }]; } });\n\nclass JwtModule {\n    constructor(parentModule) {\n        if (parentModule) {\n            throw new Error(`JwtModule is already loaded. It should only be imported in your application's main module.`);\n        }\n    }\n    static forRoot(options) {\n        return {\n            ngModule: JwtModule,\n            providers: [\n                {\n                    provide: HTTP_INTERCEPTORS,\n                    useClass: JwtInterceptor,\n                    multi: true,\n                },\n                options.jwtOptionsProvider || {\n                    provide: JWT_OPTIONS,\n                    useValue: options.config,\n                },\n                JwtHelperService,\n            ],\n        };\n    }\n}\nJwtModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.16\", ngImport: i0, type: JwtModule, deps: [{ token: JwtModule, optional: true, skipSelf: true }], target: i0.ɵɵFactoryTarget.NgModule });\nJwtModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"12.2.16\", ngImport: i0, type: JwtModule });\nJwtModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"12.2.16\", ngImport: i0, type: JwtModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.16\", ngImport: i0, type: JwtModule, decorators: [{\n            type: NgModule\n        }], ctorParameters: function () { return [{ type: JwtModule, decorators: [{\n                    type: Optional\n                }, {\n                    type: SkipSelf\n                }] }]; } });\n\n/*\n * Public API Surface of angular-jwt\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { JWT_OPTIONS, JwtHelperService, JwtInterceptor, JwtModule };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}